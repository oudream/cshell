
                              +-----------------------------------------+
                              |                  main                   |
                              |     +----------------------------+      |
                              |     |           events           |      |
                              |     +----------------------------+      |
                              |   +---------------------------------+   |
                              |   |              HTTP               |   |
                              |   |    +-----------------------+    |   |
                              |   |    |        server         |    |   |
                              |   |    |   +---------------+   |    |   |
                              |   |    |   |   location    |   |    |   |
                              |   |    |   +---------------+   |    |   |
                              |   |    |   +---------------+   |    |   |
                              |   |    |   |   location    |   |    |   |
                              |   |    |   +---------------+   |    |   |
                              |   |    +-----------------------+    |   |
                              |   |                                 |   |
                              |   |    +-----------------------+    |   |
                              |   |    |        server         |    |   |
                              |   |    +-----------------------+    |   |
                              |   |                                 |   |
                              |   |                                 |   |
                              |   +---------------------------------+   |
                              |                                         |
                              +-----------------------------------------+
                                            Nginx 配置文件





Nginx 的配置文件主要分为四个部分：

                               main(全局配置)                       # 主配置段，即全局配置段，对http,mail都有效
                               server(主机设置)                     # 主要用于指定主机和端口
                               upstream(负载均衡服务器设置)          # 主要用于负载均衡，设置一系列的后端服务器
                               location(URL匹配特定位置的设置)       # 用于匹配网页位置
                               
          四者的继承关系为：
                      location -> server -> main           upstream 既不会继承其他设置，也不会被继承 
                      
五种IO模型：                      
    同步阻塞IO模型：
    
        同步阻塞IO模型是最简单的IO模型，用户线程在内核进行IO操作时被阻塞
        
        用户线程通过系统调用read发起IO读操作，由用户空间转到内核空间。内核等到数据包到达后，然后将接收的数据拷贝到用户空间，完成read操作
        
          用户需要等待read将数据读取到buffer后，才继续处理接收的数据。整个IO请求的过程中，用户线程是被阻塞的，这导致用户在发起IO请求时，
        不能做任何事情，对CPU的资源利用率不够         
  
  
  
  
        
    同步非阻塞IO模型：
    
        用户线程发起IO请求时立即返回。但并未读取到任何数据，用户线程需要不断地发起IO请求，直到数据到达后，才真正读取到数据，继续执行。即 “轮询”机制
        
        整个IO请求的过程中，虽然用户线程每次发起IO请求后可以立即返回，但是为了等到数据，仍需要不断地轮询、重复请求，消耗了大量的CPU的资源
        
        是比较浪费CPU的方式，一般很少直接使用这种模型，而是在其他IO模型中使用非阻塞IO这一特性
        
        
        
        
        
    IO多路复用模型：
    
        多个连接共用一个等待机制，本模型会阻塞进程，但是进程是阻塞在select或者poll这两个系统调用上，而不是阻塞在真正的IO操作上
        
          用户首先将需要进行IO操作添加到select中，继续执行做其他的工作（异步），同时等待select系统调用返回。当数据到达时，IO被激活，
        select函数返回。用户线程正式发起read请求，读取数据并继续执行
        
          从流程上来看，使用select函数进行IO请求和同步阻塞模型没有太大的区别，甚至还多了添加监视IO，以及调用select函数的额外操作，效率更差。
        并且阻塞了两次，但是第一次阻塞在select上时，select可以监控多个IO上是否已有IO操作准备就绪，即可达到在同一个线程内同时处理多个IO请求的目的。
        而不像阻塞IO那种，一次只能监控一个IO
        
          虽然上述方式允许单线程内处理多个IO请求，但是每个IO请求的过程还是阻塞的（在select函数上阻塞），平均时间甚至比同步阻塞IO模型还要长。
        如果用户线程只是注册自己需要的IO请求，然后去做自己的事情，等到数据到来时再进行处理，则可以提高CPU的利用率
        IO多路复用是最常使用的IO模型，但是其异步程度还不够“彻底”，因它使用了会阻塞线程的select系统调用。因此IO多路复用只能称为异步阻塞IO模型，
        而非真正的异步IO
        
        
        
        
        
    信号驱动IO模型:
        
            用户进程可以通过sigaction系统调用注册一个信号处理程序，然后主程序可以继续向下执行，当有IO操作准备就绪时，由内核通知触发一个
            SIGIO信号处理程序执行，然后将用户进程所需要的数据从内核空间拷贝到用户空间
          
          此模型的优势在于等待数据报到达期间进程不被阻塞。用户主程序可以继续执行，只要等待来自信号处理函数的通知
          
          该模型并不常用
        
        
        
        
        
    异步IO模型
            异步IO与信号驱动IO最主要的区别是信号驱动IO是由内核通知何时可以进行IO操作，而异步IO则是由内核告诉用户线程IO操作何时完成。
          信号驱动IO当内核通知触发信号处理程序时，信号处理程序还需要阻塞在从内核空间缓冲区拷贝数据到用户空间缓冲区这个阶段，而异步IO直接是在
          第二个阶段完成后，内核直接通知用户线程可以进行后续操作了

            相比于IO多路复用模型，异步IO并不十分常用，不少高性能并发服务程序使用IO多路复用模型+多线程任务处理的架构基本可以满足需求。
          目前操作系统对异步IO的支持并非特别完善，更多的是采用IO多路复用模型模拟异步IO的方式（IO事件触发时不直接通知用户线程，
          而是将数据读写完毕后放到用户指定的缓冲区中）
    
        
                      
                               

Select：		Linux实现对应，I/O复用模型，BSD4.2最早实现
Poll：		Linux实现，对应I/O复用模型，System V unix最早实现
Epoll：		Linux实现，对应I/O复用模型，具有信号驱动I/O模型的某些特性
Kqueue：		FreeBSD实现，对应I/O复用模型，具有信号驱动I/O模型某些特性
/dev/poll：	SUN的Solaris实现，对应I/O复用模型，具有信号驱动I/O模型的某些特性
Iocp: 		 Windows实现，对应第5种（异步I/O）模型





main :

            user nginx;                                                 # 指定 Nginx 的 worker 进程运行的用户及用户组
            worker_processes auto;                                      # 指定 Nginx 要开启的进程数，此处为自动
            error_log /var/log/nginx/error.log;                         # 定义全局错误日志
            pid /run/nginx.pid;                                         # 指定进程ID的存储文件位置
            worker_rlimit_nofile 65535                                  # 一个 nginx 进程可以打开的最多的文件描述符数目
            include /usr/share/nginx/modules/*.conf;                    # 模块加载配置文件
            worker_cpu_affinity 0001 0010 0100 1000;                    # 使 worker 进程跑在某颗cpu上，提高缓存命中率。
            worker_priority number；                                    # 指定worker进程的nice值 number取值范围 [-20,19] ，默认为0 
	    
	    
            daemon  on;						        # 是否以守护进程方式运行nignx, 默认 on ,off为前台运行 nginx.
	    master_process on;						# 是否以master/worker模型运行nginx；默认为on,off 将不启动worker	
	    
            events {                                                    # 设定 Nginx 的工作模式，以及连接数上限
                use epoll;
                worker_connections 1024;                                # 每个worker进程所能够打开的最大并发连接数数量
            }
		




	
